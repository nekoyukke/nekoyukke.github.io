<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>mililiconvert on GitHub Pages</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
    <style>
        body { font-family: sans-serif; margin: 40px; background: #fafafa; }
        .textareas, input { width: 100%; margin-top: 8px; padding: 8px; }
        pre { background: #eee; padding: 12px; border-radius: 8px; }
        button { padding: 8px 16px; margin-top: 12px; cursor: pointer; }
        .editor {
            display: flex;
            width: 600px;
            height: 300px;
            border: 1px solid #dadada;
            border-radius: 4px;
            overflow: hidden;
        }

        .line-numbers {
            background: #dadada;
            color: #191919;
            padding: 8px 6px;
            text-align: right;
            user-select: none;
            white-space: pre;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.4em;
            border-right: 1px solid fafafa;
            overflow: hidden;
        }

        .text {
            flex: 1;
            border: none;
            resize: none;
            outline: none;
            background: #fafafa;
            color: #1e1e1e;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.4em;
            padding: 8px;
            overflow: auto;
        }

        .text::-webkit-scrollbar {
            width: 10px;
        }
    </style>
</head>
<body>
    <h1>ä»•æ§˜</h1>
    <h2>å‘½ä»¤</h2>
    <pre>
Mnemonics          Code                 Description
--------------------------------------------------------------
ADD r1, r2, r3     0 | r1 | r2 | r3 |   ADDitionã€‚r2ã¨r3ã‚’è¶³ã—ãŸçµæœã‚’r1ã«æ ¼ç´ r1 = r2 + r3
SUB r1, r2, r3     1 | r1 | r2 | r3 |   SUBtractionã€‚r2ã¨r3ã‚’å¼•ã„ãŸçµæœã‚’r1ã«æ ¼ç´ r1 = r2 - r3
ADDI r1, nn        2 | r1 |    nn   |   ADDition Iitionã€‚r1ã«å³å€¤nnã‚’è¶³ã—ãŸçµæœã‚’r1ã«æ ¼ç´ r1 = r1 + nn
SUBI r1, nn        3 | r1 |    nn   |   SUBtraction Iitionã€‚r1ã«å³å€¤nnã‚’å¼•ã„ãŸçµæœã‚’r1ã«æ ¼ç´ r1 = r1 - nn
NAND r1, r2, r3    4 | r1 | r2 | r3 |   Negative conjunctionã€‚r2ã¨r3ã¨ã®NANDçµæœã‚’r1ã«ä»£å…¥ r1 = NAND(r2, r3)
SHIFT r1, r2, nn   5 | r1 | r2 | nn |   SHIFT operationã€‚ã‚‚ã—nnã®4bitç›®ãŒ1ãªã‚‰å³ã‚·ãƒ•ãƒˆã€0ãªã‚‰å·¦ã‚·ãƒ•ãƒˆã€‚nnã®ä¸‹ä½3bit + 1ãŒã‚·ãƒ•ãƒˆå›æ•°ã«ãªã‚Šã¾ã™ã€‚
STORE r1, r2, r3   6 | r1 | r2 | r3 |   STOREã€‚ãƒ¡ãƒ¢ãƒªæ›¸ãè¾¼ã¿ã€‚r1ã‚’r2 * 0x100 + r3ã«æ›¸ãè¾¼ã¿ã¾ã™ã€‚
LOAD r1, r2, r3    7 | r1 | r2 | r3 |   LOADã€‚ãƒ¡ãƒ¢ãƒªèª­ã¿è¾¼ã¿ã€‚r1ã«r2 * 0x100 + r3ã‚’æ›¸ãè¾¼ã¿ã¾ã™ã€‚
BRANCH nn, r1, r2  8 | nn | r1 | r2 |   æ¡ä»¶åˆ†å²ã€‚nnã«ã‚ˆã£ã¦æŒ™å‹•ãŒå¤‰ã‚ã‚Šã¾ã™ã€‚æ¡ä»¶ãŒæº€ãŸã•ã‚Œã‚‹ã¨r1 * 0x100 + r2ã«ã‚¸ãƒ£ãƒ³ãƒ—ã—ã¾ã™ã€‚
TIMER r1, r2, r3   9 | r1 | r2 | r3 |   ã‚µãƒ–ãƒ«ãƒ¼ãƒãƒ³å‘¼ã³å‡ºã—å‘½ä»¤ã€‚r1ã®æ™‚é–“ã ã‘ã‚¯ãƒ­ãƒƒã‚¯ã‚’åœæ­¢ã•ã›ã€r2 * 0x100 + r3ã®ã‚µãƒ–ãƒ«ãƒ¼ãƒãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
RET                A | 00 |   DONT  |   ã‚µãƒ–ãƒ«ãƒ¼ãƒãƒ³å‘¼ã³å‡ºã—å…ƒã«æˆ»ã‚Šã¾ã™ã€‚
PC r1,r2           A | 01 | r1 | r2 |   PCã®å€¤ã‚’r1ã¨r2ã«æ›¸ãè¾¼ã¿ã¾ã™ã€‚
HALT               A | 0F |   DONT  |   CPUã‚’åœæ­¢ã•ã›ã¾ã™
ãƒ•ãƒ©ã‚°:
0:å¸¸ã«å½
1:å¸¸ã«çœŸ
2:ã‚­ãƒ£ãƒªãƒ¼ãƒ•ãƒ©ã‚°ãŒå½
3:ã‚­ãƒ£ãƒªãƒ¼ãƒ•ãƒ©ã‚°çœŸ
4:ã‚¼ãƒ­ãƒ•ãƒ©ã‚°ãŒå½
5:ã‚¼ãƒ­ãƒ•ãƒ©ã‚°ãŒçœŸ
6:AãŒBä»¥ä¸ŠãŒå½
7:AãŒBä»¥ä¸ŠãŒçœŸ</pre>
    <h2>ã‚¨ãƒ©ãƒ¼å‡¦ç†</h2>
    <pre>
1.å‘½ä»¤ç³»ã‚¨ãƒ©ãƒ¼
0x01:ä¸æ­£ã‚ªãƒšã‚³ãƒ¼ãƒ‰ å­˜åœ¨ã—ãªã„ã‚ªãƒšã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œ
0x02:ä¸æ­£ã‚ªãƒšãƒ©ãƒ³ãƒ‰ æœ¬æ¥0ã®ã¿ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ãŒ1

2.ãƒ¡ãƒ¢ãƒªã‚¢ã‚¯ã‚»ã‚¹ç³»ã‚¨ãƒ©ãƒ¼
0x10:æœªå‰²ã‚Šå½“ã¦ã‚¢ãƒ‰ãƒ¬ã‚¹ å‰²ã‚Šå½“ã¦ã¦ã„ãªã„é ˜åŸŸã¸ã®ã‚¢ã‚¯ã‚»ã‚¹
0x11:ãƒ¡ãƒ¢ãƒªä¿è­·é•å ã‚¢ã‚¯ã‚»ã‚¹ç¦æ­¢é ˜åŸŸã¸ã®ã‚¢ã‚¯ã‚»ã‚¹
0x12:å‘½ä»¤èª­ã¿å‡ºã—ã§å¥‡æ•°ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒ‡å®š

3.åˆ¶å¾¡ç³»ã‚¨ãƒ©ãƒ¼
0x20:ã‚¹ã‚¿ãƒƒã‚¯ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ•ãƒ­ãƒ¼ RETå®Ÿè¡Œæ™‚ã«æˆ»ã‚Šå…ˆãŒç„¡ã„
0x21:ã‚¹ã‚¿ãƒƒã‚¯ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ ã‚¹ã‚¿ãƒƒã‚¯ã«ç©ºããŒãªã„çŠ¶æ…‹ã§PUSH

4.ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ç³»ã‚¨ãƒ©ãƒ¼
0x30:ç•°å¸¸åœæ­¢ ä¸€å®šæ™‚é–“å†…ã«CPUã®å‹•ä½œã‚’æ¤œå‡ºã§ããªã‹ã£ãŸå ´åˆ</pre>
    <h2>è¦ç´„</h2>
    <p>ãƒ‡ãƒ¼ã‚¿å¹…: 8 bit</p>
    <p>ãƒ¡ãƒ¢ãƒªã‚¢ãƒ‰ãƒ¬ã‚¹å¹…: 8 or 16 bit</p>
    <p>å‘½ä»¤å¹…: 16 bit</p>
    <p>PCå¹…: 16 bit</p>
    <p>ãƒ•ãƒ©ã‚°: ã‚­ãƒ£ãƒªãƒ¼ãƒ»ã‚¼ãƒ­ãƒ»æ¯”è¼ƒ</p>
    <p>ãƒ¡ãƒ¢ãƒªå®¹é‡: 240b ~ 65.536 kib</p>
    <h3>ãƒ¬ã‚¸ã‚¹ã‚¿</h3>
    <p>r0 : ã‚¼ãƒ­ãƒ¬ã‚¸ã‚¹ã‚¿ å¸¸ã«0ã§ã™</p>
    <p>r1 ~ r10: æ±ç”¨ãƒ¬ã‚¸ã‚¹ã‚¿</p>
    <p>r11 ~ r14: é–¢æ•°ç”¨ãƒ¬ã‚¸ã‚¹ã‚¿</p>
    <p>r15: ã‚¹ã‚¿ãƒƒã‚¯ãƒ¬ã‚¸ã‚¹ã‚¿</p>
    <h3>ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ—</h3>
    <p>0x0000 ~ 0xNNEF: ãƒ¡ãƒ¢ãƒªãƒ¼</p>
    <p>0xNNF0 ~ 0xNNF7: I/O</p>
    <p>0xNNF8 ~ 0xNNFF: Input</p>
    <h1>ğŸ” Pythonã§å…¥åŠ›è§£æ</h1>
    <p>ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦è§£æã—ã¦ã¿ã‚ˆã†ï¼š</p>
    <div class="editor">
        <div id="lines" class="line-numbers">0</div>
        <textarea class="text" spellcheck="false" id="input" rows="20" placeholder="ä¾‹:
NAND r1,r0,r0
NAND r2,r0,r0
NAND r1,r0,r0
ADDI r1,39
ADDI r2,39
ADD r3,r1,r2"></textarea>
    </div>
    <textarea class="textareas" id="mode" rows="1" placeholder="0:ãƒã‚¤ãƒŠãƒª 1:ã‚³ãƒ³ãƒä»˜ã 2:æ”¹è¡Œä»˜ã"></textarea>
    <button id="ana">è§£æ</button>
    <button id="run">å¤‰æ›(16é€²æ•°)</button>
    <button id="bitrun">è§£æ(2é€²æ•°)</button>
    <h2>çµæœ:</h2>
    <pre id="output"></pre>
    <button id="Emulate">ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ</button>
    <button id="Reset">ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆãƒªã‚»ãƒƒãƒˆ</button>
    <h2>çµæœ:</h2>
    <pre id="EmulateOut"></pre>
    <pre id="EmulatePC"></pre>
    <pre id="EmulateReg"></pre>
    <pre id="EmulateMem"></pre>
    <pre id="EmulateStack"></pre>

    <script type="module">
        async function main() {
            // Pyodideã‚’ãƒ­ãƒ¼ãƒ‰
            const pyodide = await loadPyodide();
            console.log("âœ… Pyodide loaded");

            // Pythonã‚¹ã‚¯ãƒªãƒ—ãƒˆ
            const pythonCode = `
from __future__ import annotations


class Register(object):
    def __init__(self, number:int) -> None:
        self.number = number
    def __repr__(self) -> str:
        return f"r{self.number}"

class Literal(object):
    def __init__(self, value:int) -> None:
        self.value = value
    def __repr__(self) -> str:
        return str(self.value)

class Token(object):
    def __init__(self, name:str, order:list[Literal | Register]) -> None:
        self.name = name
        self.order = order
    def __repr__(self) -> str:
        if self.order:
            return f"{self.name} {' ,'.join([repr(o) for o in self.order]).replace(' ,', ',') }"
        return self.name

def lexer(Source:str) -> list[list[str]]:
    Tokens: list[list[str]] = []
    # Use splitlines() to handle CRLF/LF transparently and remove newline chars
    for line in Source.splitlines():
        # Remove comments starting with ';'
        if ';' in line:
            line = line.split(';', 1)[0]
        # Skip empty/whitespace-only lines
        if not line.strip():
            continue
        parts: list[str] = [p.strip() for p in line.split(',') if p.strip()]
        toks: list[str] = []
        for p in parts:
            toks.extend([t for t in p.split() if t != ''])
        Tokens.append(toks)
    return Tokens

def args(arg:list[str]) -> list[Literal | Register]:
    a:list[Literal | Register] = []
    for i in arg:
        token = i.strip()
        if not token:
            continue
        if token.startswith('r') and token[1:].isdecimal():
            a.append(Register(int(token[1:])))
        elif token.isdecimal():
            a.append(Literal(int(token)))
        elif token.startswith(';'):
            break
        else:
            # Unknown token; keep behavior but include token for debugging
            print(f"error: unexpected token '{token}'")
    return a

def parse(Source:list[list[str]]) -> list[Token]:
    Tokens:list[Token] = []
    for i in Source:
        print(i)
        if i == []:
            continue
        if i[0].startswith(';'):
            continue
        tok:Token = Token(i[0], args(i[1:]))
        Tokens.append(tok)
    return Tokens

def argsLoad(tok:Literal | Register, types:type[Register] | type[Literal] | None = None):
    # å‹ãƒã‚§ãƒƒã‚¯: æŒ‡å®šã•ã‚ŒãŸ types ãŒã‚ã‚Œã°ã€ãã®å‹ã¨ä¸€è‡´ã—ãªã„å ´åˆã¯æ˜ç¤ºçš„ã«ä¾‹å¤–ã‚’å‡ºã™
    if types is not None and type(tok) is not types:
        raise TypeError(f"argsLoad expected {types.__name__}, got {type(tok).__name__}")
    # å€¤ã‚’è¿”ã™: Literal ã¯ 8bitã€Register ã¯ 4bit ã‚’æƒ³å®šã—ã¦ 16é€²ã§è¿”ã™
    if isinstance(tok, Literal):
        # 2æ¡ã®16é€²ï¼ˆã‚¼ãƒ­ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ï¼‰
        return format(tok.value & 0xff, '02x')
    if isinstance(tok, Register):
        return format(tok.number & 0xf, 'x')
    raise TypeError(f"Unsupported token type: {type(tok).__name__}")

def argsLoaem(tok:Literal | Register, types:type[Register] | type[Literal] | None = None):
    # å‹ãƒã‚§ãƒƒã‚¯: æŒ‡å®šã•ã‚ŒãŸ types ãŒã‚ã‚Œã°ã€ãã®å‹ã¨ä¸€è‡´ã—ãªã„å ´åˆã¯æ˜ç¤ºçš„ã«ä¾‹å¤–ã‚’å‡ºã™
    if types is not None and type(tok) is not types:
        raise TypeError(f"argsLoad expected {types.__name__}, got {type(tok).__name__}")
    # å€¤ã‚’è¿”ã™: Literal ã¯ 8bitã€Register ã¯ 4bit ã‚’æƒ³å®šã—ã¦ 16é€²ã§è¿”ã™
    if isinstance(tok, Literal):
        # 2æ¡ã®16é€²ï¼ˆã‚¼ãƒ­ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ï¼‰
        return tok.value & 0xff
    if isinstance(tok, Register):
        return tok.number & 0xf
    raise TypeError(f"Unsupported token type: {type(tok).__name__}")

def conversion(Tokens:list[Token], mode:int):
    out:str = ""
    mode = int(mode)
    if mode < 0 or mode >= 3:
        label = ""
    else:
        label = ["", ",", "\\n"][mode]
    for i in Tokens:
        print(i)
        match (i.name.upper()):
            case "ADD":
                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:
                    # OK
                    out += "0"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Register)
                    out += argsLoad(i.order[2], Register)
                else:
                    return "Error!"
            case "SUB":
                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:
                    # OK
                    out += "1"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Register)
                    out += argsLoad(i.order[2], Register)
                else:
                    return "Error!"
            case "ADDI":
                if type(i.order[0]) == Register and type(i.order[1]) == Literal:
                    # OK
                    out += "2"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Literal)
                else:
                    return "Error!"
            case "SUBI":
                if type(i.order[0]) == Register and type(i.order[1]) == Literal:
                    # OK
                    out += "3"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Literal)
                else:
                    return "Error!"
            case "NAND":
                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:
                    # OK
                    out += "4"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Register)
                    out += argsLoad(i.order[2], Register)
                else:
                    return "Error!"
            case "SHIFT":
                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Literal:
                    # OK
                    out += "5"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Register)
                    out += hex(i.order[2].value & 0xf)[2::]
                else:
                    return "Error!"
            case "STORE":
                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:
                    # OK
                    out += "6"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Register)
                    out += argsLoad(i.order[2], Register)
                else:
                    return "Error!"
            case "LOAD":
                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:
                    # OK
                    out += "7"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Register)
                    out += argsLoad(i.order[2], Register)
                else:
                    return "Error!"
            case "BRANCH":
                if type(i.order[0]) == Literal and type(i.order[1]) == Register and type(i.order[2]) == Register:
                    # OK
                    out += "8"
                    out += hex(i.order[0].value & 0xf)[2::]
                    out += argsLoad(i.order[1], Register)
                    out += argsLoad(i.order[2], Register)
                    print("If input reg2 is odd, this may result in a poor implementation.")
                else:
                    return "Error!"
            case "TIMER":
                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:
                    # OK
                    out += "9"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Register)
                    out += argsLoad(i.order[2], Register)
                else:
                    return "Error!"
            case "RET":
                # OK
                out += "A"
                out += "000"
            case "PC":
                out += "A1"
                out += argsLoad(i.order[0], Register)
                out += argsLoad(i.order[1], Register)
            case "RNG":
                out += "A20"
                out += argsLoad(i.order[0], Register)
            case "HALT":
                # OK
                out += "A"
                out += "F00"
            case _:
                return "Error!"
        out += label
    return out

"""
ADD r1 , r2 , r3      ; r1 = r2 + r3
SUB r1 , r2 , r3      ; r1 = r2 - r3
ADDI r1 , n2          ; r1 = r1 + nn
SUBI r1 , n2          ; r1 = r1 - nn
NAND r1 , r2 , r3     ; r1 = nand( r2 , r3 )
SHIFT r1 , r2 , r3    ; r1 = floor(r2 * 2 ^ ((1 - 2 * (r3 & 0b00001000) ) * r3))
STORE r1 , r2 , r3    ; memory(r2 * 2 ^ 8 + r3) = r1
LOAD r1 , r2 , r3     ; r1 = memory(r2 * 2 ^ 8 + r3)
BRANCH flag , r1 , r2 ; å‚ç…§ãƒ•ãƒ©ã‚°ã‚’æŒ‡å®šã—ã€ãã‚ŒãŒçœŸãªã‚‰ã° r1 * 2 ^ 8 + r3 ã«ã‚¸ãƒ£ãƒ³ãƒ—
TIMER r1 , r2 , r3    ; r1 æ™‚é–“å¾…æ©Ÿã—ãŸå¾Œã« r2 * 2 ^ 8 + r3 ã«ã‚¸ãƒ£ãƒ³ãƒ—
RET                   ; ã‚µãƒ–ãƒ«ãƒ¼ãƒãƒ³ã‚’çµ‚äº†ã—ã‚µãƒ–ãƒ«ãƒ¼ãƒãƒ³å®Ÿè¡Œå‰ã«æˆ»ã‚‹
HALT                  ; åœæ­¢
"""
parsed:list[Token] = []
now:dict[str, list[int]] = {"Reg":[0,]*16, "mem":[0,]*0xff, "pc":[0], "Stack":[], "flag":[0,0,0]}
nextflag = 0
runtime = True

def is_hex(s:str):
    try:
        int(s, 16)
        return True
    except ValueError:
        return False

def analyze(text: str) -> None:
    global parsed
    lexed = lexer(text)
    parsed = parse(lexed)
    
def conv(mode:str) -> str:
    global parsed
    res = conversion(parsed, int(mode))
    return res

def bitconv(mode:str) -> str:
    global parsed
    res = conversion(parsed, int(mode))
    lres = [bin(int(i, 16))[2:].zfill(4) + "_" if is_hex(i) else i for i in res]
    return "".join(lres)

def Reset():
    global now
    now = {"Reg":[0,]*16, "mem":[0,]*0x100, "pc":[0], "Stack":[], "flag":[0,0,0]} # C Z A

def car(number:int):
    if (number&0b1000_0000)/128 == 0:
        return number&0b0111_1111
    return (number&0b0111_1111) -128

def Emulate():
    global parsed, now, nextflag, runtime
    if nextflag != 0:
        nextflag -= 1
        return "wait... calling", now
    if not runtime:
        return "runtime is end", now, nextflag, runtime
    pas:Token = parsed[now["pc"][0]]
    now["pc"][0]+=1
    match (pas.name.upper()):
        case "ADD":
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[1], Register)] + now["Reg"][argsLoaem(pas.order[2], Register)]
            if (now["Reg"][argsLoaem(pas.order[0], Register)]//256 != 0):
                now["flag"][0] = 1
            else:
                now["flag"][0] = 0
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[0], Register)]%256
            if now["Reg"][argsLoaem(pas.order[0], Register)] == 0:
                now["flag"][1] = 1
            else:
                now["flag"][1] = 0
            if car(now["Reg"][argsLoaem(pas.order[1], Register)]) >= car(now["Reg"][argsLoaem(pas.order[2], Register)]):
                now["flag"][2] = 1
            else:
                now["flag"][2] = 0
        case "SUB":
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[1], Register)] - now["Reg"][argsLoaem(pas.order[2], Register)]
            if (now["Reg"][argsLoaem(pas.order[0], Register)]//256 != 0):
                now["flag"][0] = 1
            else:
                now["flag"][0] = 0
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[0], Register)]%256
            if now["Reg"][argsLoaem(pas.order[0], Register)] == 0:
                now["flag"][1] = 1
            else:
                now["flag"][1] = 0
            if car(now["Reg"][argsLoaem(pas.order[1], Register)]) >= car(now["Reg"][argsLoaem(pas.order[2], Register)]):
                now["flag"][2] = 1
            else:
                now["flag"][2] = 0
        case "ADDI":
            now["Reg"][argsLoaem(pas.order[0], Register)] += argsLoaem(pas.order[1], Literal)
            if (now["Reg"][argsLoaem(pas.order[0], Register)]//256 != 0):
                now["flag"][0] = 1
            else:
                now["flag"][0] = 0
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[0], Register)]%256
            if now["Reg"][argsLoaem(pas.order[0], Register)] == 0:
                now["flag"][1] = 1
            else:
                now["flag"][1] = 0
            now["flag"][2] = 0
        case "SUBI":
            now["Reg"][argsLoaem(pas.order[0], Register)] -= argsLoaem(pas.order[1], Literal)
            if (now["Reg"][argsLoaem(pas.order[0], Register)]//256 != 0):
                now["flag"][0] = 1
            else:
                now["flag"][0] = 0
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[0], Register)]%256
            if now["Reg"][argsLoaem(pas.order[0], Register)] == 0:
                now["flag"][1] = 1
            else:
                now["flag"][1] = 0
            now["flag"][2] = 0
        case "NAND":
            now["Reg"][argsLoaem(pas.order[0], Register)] = ~(now["Reg"][argsLoaem(pas.order[1], Register)] ^ now["Reg"][argsLoaem(pas.order[2], Register)])
            if (now["Reg"][argsLoaem(pas.order[0], Register)]//256 != 0):
                now["flag"][0] = 1
            else:
                now["flag"][0] = 0
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[0], Register)]%256
            if now["Reg"][argsLoaem(pas.order[0], Register)] == 0:
                now["flag"][1] = 1
            else:
                now["flag"][1] = 0
            if car(now["Reg"][argsLoaem(pas.order[1], Register)]) >= car(now["Reg"][argsLoaem(pas.order[2], Register)]):
                now["flag"][2] = 1
            else:
                now["flag"][2] = 0
        case "SHIFT":
            if type(pas.order[2]) != Literal:
                raise RuntimeError("shift-2 is got literal")
            if pas.order[2].value & 0b1000 == 0:
                now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[1], Register)] << ((pas.order[2].value & 0b0111)+1)
            else:
                now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[1], Register)] >> ((pas.order[2].value & 0b0111)+1)
            
            if (now["Reg"][argsLoaem(pas.order[0], Register)]//256 != 0):
                now["flag"][0] = 1
            else:
                now["flag"][0] = 0
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[0], Register)]%256
            if now["Reg"][argsLoaem(pas.order[0], Register)] == 0:
                now["flag"][1] = 1
            else:
                now["flag"][1] = 0
            if car(now["Reg"][argsLoaem(pas.order[1], Register)]) >= car(now["Reg"][argsLoaem(pas.order[2], Literal)]):
                now["flag"][2] = 1
            else:
                now["flag"][2] = 0
        case "STORE":
            now["mem"][now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]] = now["Reg"][argsLoaem(pas.order[0], Register)]
        case "LOAD":
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["mem"][now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]]
        case "BRANCH":
            if type(pas.order[0]) != Literal:
                raise RuntimeError("shift-0 is got literal")
            match (pas.order[0].value & 0xf):
                case 0:
                    pass
                case 1:
                    now["pc"][0] = now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]
                case 2:
                    if now["flag"][0] == 0:
                        now["pc"][0] = now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]
                case 3:
                    if now["flag"][0] != 0:
                        now["pc"][0] = now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]
                case 4:
                    if now["flag"][1] == 0:
                        now["pc"][0] = now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]
                case 5:
                    if now["flag"][1] != 0:
                        now["pc"][0] = now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]
                case 6:
                    if now["flag"][2] == 0:
                        now["pc"][0] = now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]
                case 7:
                    if now["flag"][2] != 0:
                        now["pc"][0] = now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]
                case _:
                    raise RuntimeError("unkown Number")
        case "TIMER":
            nextflag = now["Reg"][argsLoaem(pas.order[0], Register)]
            now["Stack"].append(now["pc"][0])
            now["pc"][0] = now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]
        case "RET":
            now["pc"][0] = now["Stack"].pop(-1)
        case "PC":
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["pc"][0]& 0xff00
            now["Reg"][argsLoaem(pas.order[1], Register)] = now["pc"][0]& 0x00ff
        case "HALT":
            runtime = False
        case _:
            return "Error! unkwonCode", now
    now["Reg"][0] = 0 # RZ is zero
    return pas.__repr__(), now
`;

            await pyodide.runPythonAsync(pythonCode);

            function text32(liststring) {
                let res = ""
                for (let i = 0; i < liststring.length; i++) {
                    res += liststring[i];
                    if (i%32 == 31) {
                        // ãˆãˆ
                        res += "\n";
                    } else {
                        res += ", "
                    }
                }
                return res;
            }

            document.getElementById("ana").onclick = async () => {
                const text = document.getElementById("input").value;
                try {
                    pyodide.globals.set("user_input", text);
                    const result = await pyodide.runPythonAsync("analyze(user_input)");
                } catch (err) {
                    document.getElementById("output").textContent = "âš ï¸ ã‚¨ãƒ©ãƒ¼: " + err;
                }
            };
            document.getElementById("bitrun").onclick = async () => {
                const mode = parseInt(document.getElementById("mode").value) || 0;
                try {
                    pyodide.globals.set("mode", mode);
                    const result = await pyodide.runPythonAsync("bitconv(mode)");
                    document.getElementById("output").textContent = result;
                } catch (err) {
                    document.getElementById("output").textContent = "âš ï¸ ã‚¨ãƒ©ãƒ¼: " + err;
                }
            };
            document.getElementById("run").onclick = async () => {
                const mode = parseInt(document.getElementById("mode").value) || 0;
                try {
                    pyodide.globals.set("mode", mode);
                    const result = await pyodide.runPythonAsync("conv(mode)");
                    document.getElementById("output").textContent = result;
                } catch (err) {
                    document.getElementById("output").textContent = "âš ï¸ ã‚¨ãƒ©ãƒ¼: " + err;
                }
            };
            document.getElementById("Reset").onclick = async () => {
                try {
                    const result = await pyodide.runPythonAsync("Reset()");
                } catch (err) {
                    document.getElementById("EmulateOut").textContent = "âš ï¸ ã‚¨ãƒ©ãƒ¼: " + err;
                }
            };
            // emureat
            document.getElementById("Emulate").onclick = async () => {
                try {
                    const res = await pyodide.runPythonAsync("Emulate()");
                    const result = res.toJs({ deep: true });
                    console.log(result[0]);
                    console.log(document.getElementById("EmulateOut"));
                    const restext = result[0];
                    const cpu = result[1];
                    const pc = cpu.get("pc")[0] - 1;
                    const Reg = cpu.get("Reg");
                    const mem = cpu.get("mem");
                    const Stack = cpu.get("Stack");
                    document.getElementById("EmulateOut").textContent = restext;
                    document.getElementById("EmulatePC").textContent = pc;
                    document.getElementById("EmulateReg").textContent = Reg.join(", ");
                    document.getElementById("EmulateMem").textContent = text32(mem);
                    document.getElementById("EmulateStack").textContent = Stack.join(", ");
                } catch (err) {
                    document.getElementById("EmulateOut").textContent = "âš ï¸ ã‚¨ãƒ©ãƒ¼: " + err;
                }
            };
        }
        main();
        const code = document.getElementById("input");
        const lines = document.getElementById("lines");

        function updateLineNumbers() {
            const lineCount = code.value.split("\n").length;
            lines.textContent = Array.from({ length: lineCount }, (_, i) => i).join("\n");
        }

        code.addEventListener("input", updateLineNumbers);
        code.addEventListener("scroll", () => {
            lines.scrollTop = code.scrollTop;
        });

        updateLineNumbers();
    </script>
</body>
</html>
