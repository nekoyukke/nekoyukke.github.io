<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>mililiconvert on GitHub Pages</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
    <style>
        body { font-family: sans-serif; margin: 40px; background: #fafafa; }
        .textareas, input { width: 100%; margin-top: 8px; padding: 8px; }
        pre { background: #eee; padding: 12px; border-radius: 8px; }
        button { padding: 8px 16px; margin-top: 12px; cursor: pointer; }
        .editor {
            display: flex;
            width: 600px;
            height: 300px;
            border: 1px solid #dadada;
            border-radius: 4px;
            overflow: hidden;
        }

        .line-numbers {
            background: #dadada;
            color: #191919;
            padding: 8px 6px;
            text-align: right;
            user-select: none;
            white-space: pre;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.4em;
            border-right: 1px solid fafafa;
            overflow: hidden;
        }

        .text {
            flex: 1;
            border: none;
            resize: none;
            outline: none;
            background: #fafafa;
            color: #1e1e1e;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.4em;
            padding: 8px;
            overflow: auto;
        }

        .text::-webkit-scrollbar {
            width: 10px;
        }
    </style>
</head>
<body>
    <h1>🔍 Pythonで入力解析</h1>
    <p>テキストを入力して解析してみよう：</p>
    <div class="editor">
        <div id="lines" class="line-numbers">0</div>
        <textarea class="text" spellcheck="false" id="input" rows="20" placeholder="例:
NAND r1,r0,r0
NAND r2,r0,r0
NAND r1,r0,r0
ADDI r1,39
ADDI r2,39
ADD r3,r1,r2"></textarea>
    </div>
    <textarea class="textareas" id="mode" rows="1" placeholder="0:バイナリ 1:コンマ付き 2:改行付き"></textarea>
    <button id="ana">解析</button>
    <button id="run">変換(16進数)</button>
    <button id="bitrun">解析(2進数)</button>
    <h2>結果:</h2>
    <pre id="output"></pre>
    <button id="Emulate">エミュレート</button>
    <button id="Reset">エミュレートリセット</button>
    <h2>結果:</h2>
    <pre id="EmulateOut"></pre>
    <pre id="EmulatePC"></pre>
    <pre id="EmulateReg"></pre>
    <pre id="EmulateMem"></pre>
    <pre id="EmulateStack"></pre>

    <script type="module">
        async function main() {
            // Pyodideをロード
            const pyodide = await loadPyodide();
            console.log("✅ Pyodide loaded");

            // Pythonスクリプト
            const pythonCode = `
from __future__ import annotations


class Register(object):
    def __init__(self, number:int) -> None:
        self.number = number
    def __repr__(self) -> str:
        return f"r{self.number}"

class Literal(object):
    def __init__(self, value:int) -> None:
        self.value = value
    def __repr__(self) -> str:
        return str(self.value)

class Token(object):
    def __init__(self, name:str, order:list[Literal | Register]) -> None:
        self.name = name
        self.order = order
    def __repr__(self) -> str:
        if self.order:
            return f"{self.name} {' ,'.join([repr(o) for o in self.order]).replace(' ,', ',') }"
        return self.name

def lexer(Source:str) -> list[list[str]]:
    Tokens: list[list[str]] = []
    # Use splitlines() to handle CRLF/LF transparently and remove newline chars
    for line in Source.splitlines():
        # Remove comments starting with ';'
        if ';' in line:
            line = line.split(';', 1)[0]
        # Skip empty/whitespace-only lines
        if not line.strip():
            continue
        parts: list[str] = [p.strip() for p in line.split(',') if p.strip()]
        toks: list[str] = []
        for p in parts:
            toks.extend([t for t in p.split() if t != ''])
        Tokens.append(toks)
    return Tokens

def args(arg:list[str]) -> list[Literal | Register]:
    a:list[Literal | Register] = []
    for i in arg:
        token = i.strip()
        if not token:
            continue
        if token.startswith('r') and token[1:].isdecimal():
            a.append(Register(int(token[1:])))
        elif token.isdecimal():
            a.append(Literal(int(token)))
        elif token.startswith(';'):
            break
        else:
            # Unknown token; keep behavior but include token for debugging
            print(f"error: unexpected token '{token}'")
    return a

def parse(Source:list[list[str]]) -> list[Token]:
    Tokens:list[Token] = []
    for i in Source:
        print(i)
        if i == []:
            continue
        if i[0].startswith(';'):
            continue
        tok:Token = Token(i[0], args(i[1:]))
        Tokens.append(tok)
    return Tokens

def argsLoad(tok:Literal | Register, types:type[Register] | type[Literal] | None = None):
    # 型チェック: 指定された types があれば、その型と一致しない場合は明示的に例外を出す
    if types is not None and type(tok) is not types:
        raise TypeError(f"argsLoad expected {types.__name__}, got {type(tok).__name__}")
    # 値を返す: Literal は 8bit、Register は 4bit を想定して 16進で返す
    if isinstance(tok, Literal):
        # 2桁の16進（ゼロパディング）
        return format(tok.value & 0xff, '02x')
    if isinstance(tok, Register):
        return format(tok.number & 0xf, 'x')
    raise TypeError(f"Unsupported token type: {type(tok).__name__}")

def argsLoaem(tok:Literal | Register, types:type[Register] | type[Literal] | None = None):
    # 型チェック: 指定された types があれば、その型と一致しない場合は明示的に例外を出す
    if types is not None and type(tok) is not types:
        raise TypeError(f"argsLoad expected {types.__name__}, got {type(tok).__name__}")
    # 値を返す: Literal は 8bit、Register は 4bit を想定して 16進で返す
    if isinstance(tok, Literal):
        # 2桁の16進（ゼロパディング）
        return tok.value & 0xff
    if isinstance(tok, Register):
        return tok.number & 0xf
    raise TypeError(f"Unsupported token type: {type(tok).__name__}")

def conversion(Tokens:list[Token], mode:int):
    out:str = ""
    mode = int(mode)
    if mode < 0 or mode >= 3:
        label = ""
    else:
        label = ["", ",", "\\n"][mode]
    for i in Tokens:
        print(i)
        match (i.name.upper()):
            case "ADD":
                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:
                    # OK
                    out += "0"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Register)
                    out += argsLoad(i.order[2], Register)
                else:
                    return "Error!"
            case "SUB":
                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:
                    # OK
                    out += "1"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Register)
                    out += argsLoad(i.order[2], Register)
                else:
                    return "Error!"
            case "ADDI":
                if type(i.order[0]) == Register and type(i.order[1]) == Literal:
                    # OK
                    out += "2"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Literal)
                else:
                    return "Error!"
            case "SUBI":
                if type(i.order[0]) == Register and type(i.order[1]) == Literal:
                    # OK
                    out += "3"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Literal)
                else:
                    return "Error!"
            case "NAND":
                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:
                    # OK
                    out += "4"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Register)
                    out += argsLoad(i.order[2], Register)
                else:
                    return "Error!"
            case "SHIFT":
                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Literal:
                    # OK
                    out += "5"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Register)
                    out += hex(i.order[2].value & 0xf)[2::]
                else:
                    return "Error!"
            case "STORE":
                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:
                    # OK
                    out += "6"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Register)
                    out += argsLoad(i.order[2], Register)
                else:
                    return "Error!"
            case "LOAD":
                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:
                    # OK
                    out += "7"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Register)
                    out += argsLoad(i.order[2], Register)
                else:
                    return "Error!"
            case "BRANCH":
                if type(i.order[0]) == Literal and type(i.order[1]) == Register and type(i.order[2]) == Register:
                    # OK
                    out += "8"
                    out += hex(i.order[0].value & 0xf)[2::]
                    out += argsLoad(i.order[1], Register)
                    out += argsLoad(i.order[2], Register)
                    print("If input reg2 is odd, this may result in a poor implementation.")
                else:
                    return "Error!"
            case "TIMER":
                if type(i.order[0]) == Register and type(i.order[1]) == Register and type(i.order[2]) == Register:
                    # OK
                    out += "9"
                    out += argsLoad(i.order[0], Register)
                    out += argsLoad(i.order[1], Register)
                    out += argsLoad(i.order[2], Register)
                else:
                    return "Error!"
            case "RET":
                # OK
                out += "A"
                out += "000"
            case "PC":
                out += "A1"
                out += argsLoad(i.order[0], Register)
                out += argsLoad(i.order[1], Register)
            case "RNG":
                out += "A20"
                out += argsLoad(i.order[0], Register)
            case "HALT":
                # OK
                out += "A"
                out += "F00"
            case _:
                return "Error!"
        out += label
    return out

"""
ADD r1 , r2 , r3      ; r1 = r2 + r3
SUB r1 , r2 , r3      ; r1 = r2 - r3
ADDI r1 , n2          ; r1 = r1 + nn
SUBI r1 , n2          ; r1 = r1 - nn
NAND r1 , r2 , r3     ; r1 = nand( r2 , r3 )
SHIFT r1 , r2 , r3    ; r1 = floor(r2 * 2 ^ ((1 - 2 * (r3 & 0b00001000) ) * r3))
STORE r1 , r2 , r3    ; memory(r2 * 2 ^ 8 + r3) = r1
LOAD r1 , r2 , r3     ; r1 = memory(r2 * 2 ^ 8 + r3)
BRANCH flag , r1 , r2 ; 参照フラグを指定し、それが真ならば r1 * 2 ^ 8 + r3 にジャンプ
TIMER r1 , r2 , r3    ; r1 時間待機した後に r2 * 2 ^ 8 + r3 にジャンプ
RET                   ; サブルーチンを終了しサブルーチン実行前に戻る
HALT                  ; 停止
"""
parsed:list[Token] = []
now:dict[str, list[int]] = {"Reg":[0,]*16, "mem":[0,]*0xff, "pc":[0], "Stack":[], "flag":[0,0,0]}
nextflag = 0
runtime = True

def is_hex(s:str):
    try:
        int(s, 16)
        return True
    except ValueError:
        return False

def analyze(text: str) -> None:
    global parsed
    lexed = lexer(text)
    parsed = parse(lexed)
    
def conv(mode:str) -> str:
    global parsed
    res = conversion(parsed, int(mode))
    return res

def bitconv(mode:str) -> str:
    global parsed
    res = conversion(parsed, int(mode))
    lres = [bin(int(i, 16))[2:].zfill(4) + "_" if is_hex(i) else i for i in res]
    return "".join(lres)

def Reset():
    global now
    now = {"Reg":[0,]*16, "mem":[0,]*0x100, "pc":[0], "Stack":[], "flag":[0,0,0]} # C Z A

def car(number:int):
    if (number&0b1000_0000)/128 == 0:
        return number&0b0111_1111
    return (number&0b0111_1111) -128

def Emulate():
    global parsed, now, nextflag, runtime
    if nextflag != 0:
        nextflag -= 1
        return "wait... calling", now
    if not runtime:
        return "runtime is end", now, nextflag, runtime
    pas:Token = parsed[now["pc"][0]]
    now["pc"][0]+=1
    match (pas.name.upper()):
        case "ADD":
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[1], Register)] + now["Reg"][argsLoaem(pas.order[2], Register)]
            if (now["Reg"][argsLoaem(pas.order[0], Register)]//256 != 0):
                now["flag"][0] = 1
            else:
                now["flag"][0] = 0
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[0], Register)]%256
            if now["Reg"][argsLoaem(pas.order[0], Register)] == 0:
                now["flag"][1] = 1
            else:
                now["flag"][1] = 0
            if car(now["Reg"][argsLoaem(pas.order[1], Register)]) >= car(now["Reg"][argsLoaem(pas.order[2], Register)]):
                now["flag"][2] = 1
            else:
                now["flag"][2] = 0
        case "SUB":
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[1], Register)] - now["Reg"][argsLoaem(pas.order[2], Register)]
            if (now["Reg"][argsLoaem(pas.order[0], Register)]//256 != 0):
                now["flag"][0] = 1
            else:
                now["flag"][0] = 0
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[0], Register)]%256
            if now["Reg"][argsLoaem(pas.order[0], Register)] == 0:
                now["flag"][1] = 1
            else:
                now["flag"][1] = 0
            if car(now["Reg"][argsLoaem(pas.order[1], Register)]) >= car(now["Reg"][argsLoaem(pas.order[2], Register)]):
                now["flag"][2] = 1
            else:
                now["flag"][2] = 0
        case "ADDI":
            now["Reg"][argsLoaem(pas.order[0], Register)] += argsLoaem(pas.order[1], Literal)
            if (now["Reg"][argsLoaem(pas.order[0], Register)]//256 != 0):
                now["flag"][0] = 1
            else:
                now["flag"][0] = 0
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[0], Register)]%256
            if now["Reg"][argsLoaem(pas.order[0], Register)] == 0:
                now["flag"][1] = 1
            else:
                now["flag"][1] = 0
            now["flag"][2] = 0
        case "SUBI":
            now["Reg"][argsLoaem(pas.order[0], Register)] -= argsLoaem(pas.order[1], Literal)
            if (now["Reg"][argsLoaem(pas.order[0], Register)]//256 != 0):
                now["flag"][0] = 1
            else:
                now["flag"][0] = 0
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[0], Register)]%256
            if now["Reg"][argsLoaem(pas.order[0], Register)] == 0:
                now["flag"][1] = 1
            else:
                now["flag"][1] = 0
            now["flag"][2] = 0
        case "NAND":
            now["Reg"][argsLoaem(pas.order[0], Register)] = ~(now["Reg"][argsLoaem(pas.order[1], Register)] ^ now["Reg"][argsLoaem(pas.order[2], Register)])
            if (now["Reg"][argsLoaem(pas.order[0], Register)]//256 != 0):
                now["flag"][0] = 1
            else:
                now["flag"][0] = 0
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[0], Register)]%256
            if now["Reg"][argsLoaem(pas.order[0], Register)] == 0:
                now["flag"][1] = 1
            else:
                now["flag"][1] = 0
            if car(now["Reg"][argsLoaem(pas.order[1], Register)]) >= car(now["Reg"][argsLoaem(pas.order[2], Register)]):
                now["flag"][2] = 1
            else:
                now["flag"][2] = 0
        case "SHIFT":
            if type(pas.order[2]) != Literal:
                raise RuntimeError("shift-2 is got literal")
            if pas.order[2].value & 0b1000 == 0:
                now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[1], Register)] << (pas.order[2].value & 0b0111+1)
            else:
                now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[1], Register)] >> (pas.order[2].value & 0b0111+1)
            
            if (now["Reg"][argsLoaem(pas.order[0], Register)]//256 != 0):
                now["flag"][0] = 1
            else:
                now["flag"][0] = 0
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["Reg"][argsLoaem(pas.order[0], Register)]%256
            if now["Reg"][argsLoaem(pas.order[0], Register)] == 0:
                now["flag"][1] = 1
            else:
                now["flag"][1] = 0
            if car(now["Reg"][argsLoaem(pas.order[1], Register)]) >= car(now["Reg"][argsLoaem(pas.order[2], Literal)]):
                now["flag"][2] = 1
            else:
                now["flag"][2] = 0
        case "STORE":
            now["mem"][now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]] = now["Reg"][argsLoaem(pas.order[0], Register)]
        case "LOAD":
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["mem"][now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]]
        case "BRANCH":
            if type(pas.order[0]) != Literal:
                raise RuntimeError("shift-0 is got literal")
            match (pas.order[0].value & 0xf):
                case 0:
                    pass
                case 1:
                    now["pc"][0] = now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]
                case 2:
                    if now["flag"][0] == 0:
                        now["pc"][0] = now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]
                case 3:
                    if now["flag"][0] != 0:
                        now["pc"][0] = now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]
                case 4:
                    if now["flag"][1] == 0:
                        now["pc"][0] = now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]
                case 5:
                    if now["flag"][1] != 0:
                        now["pc"][0] = now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]
                case 6:
                    if now["flag"][2] == 0:
                        now["pc"][0] = now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]
                case 7:
                    if now["flag"][2] != 0:
                        now["pc"][0] = now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]
                case _:
                    raise RuntimeError("unkown Number")
        case "TIMER":
            nextflag = now["Reg"][argsLoaem(pas.order[0], Register)]
            now["Stack"].append(now["pc"][0])
            now["pc"][0] = now["Reg"][argsLoaem(pas.order[1], Register)] * 0x100 + now["Reg"][argsLoaem(pas.order[2], Register)]
        case "RET":
            now["pc"][0] = now["Stack"].pop(-1)
        case "PC":
            now["Reg"][argsLoaem(pas.order[0], Register)] = now["pc"][0]& 0xff00
            now["Reg"][argsLoaem(pas.order[1], Register)] = now["pc"][0]& 0x00ff
        case "HALT":
            runtime = False
        case _:
            return "Error! unkwonCode", now
    now["Reg"][0] = 0 # RZ is zero
    return pas.__repr__(), now
`;

            await pyodide.runPythonAsync(pythonCode);

            function text32(liststring) {
                let res = ""
                for (let i = 0; i < liststring.length; i++) {
                    res += liststring[i];
                    if (i%32 == 31) {
                        // ええ
                        res += "\n";
                    } else {
                        res += ", "
                    }
                }
                return res;
            }

            document.getElementById("ana").onclick = async () => {
                const text = document.getElementById("input").value;
                try {
                    pyodide.globals.set("user_input", text);
                    const result = await pyodide.runPythonAsync("analyze(user_input)");
                } catch (err) {
                    document.getElementById("output").textContent = "⚠️ エラー: " + err;
                }
            };
            document.getElementById("bitrun").onclick = async () => {
                const mode = parseInt(document.getElementById("mode").value) || 0;
                try {
                    pyodide.globals.set("mode", mode);
                    const result = await pyodide.runPythonAsync("bitconv(mode)");
                    document.getElementById("output").textContent = result;
                } catch (err) {
                    document.getElementById("output").textContent = "⚠️ エラー: " + err;
                }
            };
            document.getElementById("run").onclick = async () => {
                const mode = parseInt(document.getElementById("mode").value) || 0;
                try {
                    pyodide.globals.set("mode", mode);
                    const result = await pyodide.runPythonAsync("conv(mode)");
                    document.getElementById("output").textContent = result;
                } catch (err) {
                    document.getElementById("output").textContent = "⚠️ エラー: " + err;
                }
            };
            document.getElementById("Reset").onclick = async () => {
                try {
                    const result = await pyodide.runPythonAsync("Reset()");
                } catch (err) {
                    document.getElementById("EmulateOut").textContent = "⚠️ エラー: " + err;
                }
            };
            // emureat
            document.getElementById("Emulate").onclick = async () => {
                try {
                    const res = await pyodide.runPythonAsync("Emulate()");
                    const result = res.toJs({ deep: true });
                    console.log(result[0]);
                    console.log(document.getElementById("EmulateOut"));
                    const restext = result[0];
                    const cpu = result[1];
                    const pc = cpu.get("pc")[0] - 1;
                    const Reg = cpu.get("Reg");
                    const mem = cpu.get("mem");
                    const Stack = cpu.get("Stack");
                    document.getElementById("EmulateOut").textContent = restext;
                    document.getElementById("EmulatePC").textContent = pc;
                    document.getElementById("EmulateReg").textContent = Reg.join(", ");
                    document.getElementById("EmulateMem").textContent = text32(mem);
                    document.getElementById("EmulateStack").textContent = Stack.join(", ");
                } catch (err) {
                    document.getElementById("EmulateOut").textContent = "⚠️ エラー: " + err;
                }
            };
        }
        main();
        const code = document.getElementById("input");
        const lines = document.getElementById("lines");

        function updateLineNumbers() {
            const lineCount = code.value.split("\n").length;
            lines.textContent = Array.from({ length: lineCount }, (_, i) => i).join("\n");
        }

        code.addEventListener("input", updateLineNumbers);
        code.addEventListener("scroll", () => {
            lines.scrollTop = code.scrollTop;
        });

        updateLineNumbers();
    </script>
</body>
</html>
